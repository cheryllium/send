#!/usr/bin/env sh
/* 2>/dev/null
DOCKER_IMAGE=openjdk:11
DOCKER_CMD="/bin/bash -c 'javac "

pwd=$(cd "$(dirname "$0")" && pwd);s="$pwd/$(basename "$0")";docker run --rm -a stdin -a stdout -a stderr -i$([ -t 0 ] && echo t) --init -v "$s":"$s":ro -v /var/run/docker.sock:/var/run/docker.sock ${DOCKER_EXTRA_ARGS} ${DOCKER_IMAGE} /bin/bash -c "java --source 6 \"$s\" \"$pwd\"; bash";exit $?

This self-contained script runner for Docker via:
https://github.com/hugojosefson/docker-shebang
*/
import java.util.List;
import java.util.LinkedList;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class Main {
    private static final String DOCKER_IMAGE_NAME = "firefox-send";

    protected static String currentWorkingDirectory;

    public static void main(String[] args) {
        System.out.println(
            "############################\n" + 
            "# Extensible Docker System #\n" + 
            "############################");
            
        if (args.length == 0) {
            System.err.println("You must pass the current working directory as the first argument");
            System.exit(1);
        }
        currentWorkingDirectory = args[0];


        installDockerDependencies();
        System.out.println("Dependencies ready. Beginning script");
        runBuildCommand();
        System.out.println("Docker image built, beginning execution");
        runDockerRunCommand();
        System.out.println("Docker image running");
    }

    private static void runBuildCommand() {
        DockerCommandBuilder dockerCommandBuilder = new DockerCommandBuilder();
        dockerCommandBuilder.setBaseCommandForDocker(DockerCommand.DEFAULT_BASE_COMMAND_FOR_DOCKER);
        dockerCommandBuilder.setDockerSubcommand(DockerCommand.DOCKER_BUILD_SUBCOMMAND);
        String[] parameters = {"-f", "Dockerfile.dev", "-t", DOCKER_IMAGE_NAME, "."};
        dockerCommandBuilder.setDockerParameters(parameters);
        DockerCommand dockerCommand = dockerCommandBuilder.build();

        ProcessBuilder processBuilder = new ProcessBuilder();
        processBuilder.command(dockerCommand.getCommand());
        try
        {
            System.out.println("Getting ready to run docker build");
            Process process = processBuilder.start();
            System.out.println("Started docker build");
            InputStream output = process.getErrorStream();
            byte[] buffer = new byte[10];
            int count = output.read(buffer);
            for (; count > 0; count = output.read(buffer))
            {
                System.err.write(buffer, 0, count);
            }
            System.out.println("Done writing");
        }
        catch (IOException e)
        {
            System.err.println("Failed when running docker build command");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void runDockerRunCommand() {
        DockerCommandBuilder dockerCommandBuilder = new DockerCommandBuilder();
        dockerCommandBuilder.setBaseCommandForDocker(DockerCommand.DEFAULT_BASE_COMMAND_FOR_DOCKER);
        dockerCommandBuilder.setDockerSubcommand(DockerCommand.DOCKER_RUN_SUBCOMMAND);
        String volumeMountParameter = getVolumeMountParameter();
        String[] parameters = {"-i", "-t", "--env-file", ".docker.env.dev",
                               "-v", volumeMountParameter,
                               "-p", "4001:4001",
                               DOCKER_IMAGE_NAME};

        dockerCommandBuilder.setDockerParameters(parameters);
        DockerCommand dockerCommand = dockerCommandBuilder.build();

        ProcessBuilder processBuilder = new ProcessBuilder();
        processBuilder.command(dockerCommand.getCommand());
        try
        {
            processBuilder.start().waitFor();
        }
        catch (Exception e)
        {
            System.err.println("Failed when running docker run command");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static String getVolumeMountParameter() {
        StringBuffer stringBuilder = new StringBuffer();
        stringBuilder.append(currentWorkingDirectory);
        stringBuilder.append("/");
        stringBuilder.append("/app");
        return stringBuilder.toString();
    }

    // TODO: Clean up this method and move to another class to decouple
    private static boolean installDockerDependencies() {
        String curlCommand = "curl";
        String[] extraArguments = {"https://get.docker.com"};
        String shellCommand = "sh";

        String[] fullCommand = new String[2];
        fullCommand[0] = curlCommand;
        for (int i = 0; i < extraArguments.length; i++) {
            fullCommand[i + 1] = extraArguments[i];
        }

        ProcessBuilder processBuilder = new ProcessBuilder();
        processBuilder.command((String[]) fullCommand);
        try
        {
            Process curlProcess = processBuilder.start();
            InputStream output = curlProcess.getInputStream();
            ProcessBuilder shCommandBuilder = new ProcessBuilder();
            shCommandBuilder.command(shellCommand);
            shCommandBuilder.redirectErrorStream(true);
            Process shProcess = shCommandBuilder.start();
            OutputStream shCommandInput = shProcess.getOutputStream();

            System.out.println("Startign");
            System.out.println("Piping");
            byte[] buffer = new byte[10];
            int count = output.read(buffer);
            for (; count > 0; count = output.read(buffer))
            {
                shCommandInput.write(buffer, 0, count);
            }
            shCommandInput.flush();
            shCommandInput.close();
            System.out.println("Starting docker install");

            output = shProcess.getInputStream();
            count = output.read(buffer);
            for (; count > 0; count = output.read(buffer))
            {
                System.out.write(buffer, 0, count);
            }
            
        }
        catch (IOException e)
        {
            throw new IllegalStateException("Could not install dependencies", e);
        }
        catch (Exception e) {
            System.out.println("Error while trying to set up");
        }
        return true;

    }
}
class DockerCommandBuilder {
    String baseCommandForDocker;
    String dockerSubCommand;
    String[] dockerParameters;

    public DockerCommandBuilder setBaseCommandForDocker
        (String newBaseCommandForDocker)
    {
        this.baseCommandForDocker = newBaseCommandForDocker;
        return this;
    }

    public DockerCommandBuilder setDockerSubcommand
        (String newDockerSubCommand)
    {
        this.dockerSubCommand = newDockerSubCommand;
        return this;
    }

    public DockerCommandBuilder setDockerParameters
        (String[] newDockerParameters)
    {
        this.dockerParameters = newDockerParameters;
        return this;
    }

    public DockerCommand build()
    {
        if (null == baseCommandForDocker)
        {
            throw new DockerCommandException("Base command was null!");
        }
        if (null == dockerSubCommand)
        {
            throw new DockerCommandException("Docker sub command was null!");
        }
        if (null == dockerParameters)
        {
            throw new DockerCommandException("Docker parameters were null!");
        }
        return new DockerCommand(
            baseCommandForDocker,
            dockerSubCommand,
            dockerParameters);
    }
}
class DockerCommand {
    static final String DEFAULT_BASE_COMMAND_FOR_DOCKER = "docker";
    static final String DOCKER_BUILD_SUBCOMMAND = "build";
    static final String DOCKER_RUN_SUBCOMMAND = "run";

    String baseCommandForDocker;
    String dockerSubCommand;
    String[] dockerParameters;

    DockerCommand(String baseCommandForDocker, String dockerSubCommand, String [] dockerParameters)
    {
        this.baseCommandForDocker = baseCommandForDocker;
        this.dockerSubCommand = dockerSubCommand;
        this.dockerParameters = dockerParameters;
    }

    public List getCommand()
    {
        List command = new LinkedList();
        command.add(0, this.baseCommandForDocker);
        command.add(1, this.dockerSubCommand);
        for (int i = 0; i < this.dockerParameters.length; ++i)
        {
            command.add(i + 2, this.dockerParameters[i]);
        }
        return command;
    }
    
}
class DockerCommandException extends IllegalArgumentException {
    public DockerCommandException() 
    {
        super();
    }
    public DockerCommandException(String message) 
    {
        super(message);
    }
    public DockerCommandException(String message, Throwable cause) 
    {
        super(message, cause);
    }
}
